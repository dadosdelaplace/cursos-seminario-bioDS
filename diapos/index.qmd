---
title: "Tidyverse y Quarto"
subtitle: "Seminario de tidyverse y Quarto para docencia e investigaci√≥n"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Seminarios BioDS ‚Ä¢ curso 2023-2024"
affiliation: Facultad de Estudios Estad√≠sticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    chalkboard: true
    multiplex: true
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier √Ålvarez Li√©bana</strong>](...) ‚Ä¢ Seminarios BioDS (UCM) ‚Ä¢ curso 2023-2024"
    slide-number: c/t
execute:
  echo: true
---

# ¬°Bienvenidos a tidyverse!

[**Dejad vuestros bucles a un lado**]{style="color:#444442;"}

---


## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Entender los [**conceptos b√°sicos de tidyverse**]{.hl-yellow} desde cero ‚Üí aprender programar funcional (sin bucles)

-   Utilidad de tidyverse ‚Üí flujos de trabajo [**reproducibles**, **legibles**, **transparentes**]{.hl-yellow} y mantenibles

-   Introducci√≥n a [**Quarto**]{.hl-yellow} ‚Üí elaboraci√≥n de material docente

-   Introducci√≥n a Github en RStudio
:::
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: las diapositivas que usaremos disponibles y actualizadas en **<https://javieralvarezliebana.es/seminario-R-biods/diapos>** 

En el men√∫ de las diapositivas (abajo a la izquierda) tienes una [**opci√≥n para descargarlas en pdf**]{.hl-yellow} en `Tools` (consejo: no lo hagas hasta el final del curso ya que ir√°n modific√°ndose)
  
&nbsp;


* [**Res√∫menes de paquetes**]{.hl-yellow}: [**chuletas de los paquetes**](https://github.com/dadosdelaplace/seminario-R-biods/tree/main/fichas%20paquetes) en formato .pdf


---

## S√© organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto ser√° una ¬´carpeta¬ª**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio ra√≠z autom√°ticamente ser√° la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


# Intentos de bases de datos {#bloque-I}

[**Matrices y data.frames**]{style="color:#444442;"}


---

## Primera intento: matrices

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una ¬´tabla¬ª que las recopile. La opci√≥n m√°s inmediata son las [**matrices**]{.hl-yellow}: concatenaci√≥n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

. . .

```{r}
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---


## Primer intento: matrices

Tambi√©n podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la funci√≥n `apply()`, y le indicaremos como **argumentos**

- la matriz
- el sentido de la operaci√≥n (MARGIN = 1 por filas, MARGIN = 2 por columnas)
- la funci√≥n a aplicar

. . .

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```


```{r}
# (Cuasi)varianza (var) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "var")
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaci√≥n de variables de igual longitud pero pueden ser de [**tipo distinto**]{.hl-purple}.

Dado que un `data.frame` es ya una ¬´base de datos¬ª las variables no son meros vectores matem√°ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}

```{r}
library(lubridate)
tabla <- data.frame("edad" = 25:27, "estado" = c(TRUE, NA, FALSE),
                    "nombre" = c("javi", "sandra", "carlos"),
                    "f_nacimiento" = as_date(c("1989-09-10", "1996-06-12", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

Si queremos acceder a sus elementos, podemos como en las matrices (aunque no es recomendable): ahora [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracter√≠stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Tambi√©n tiene ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} (**recomendable** ya que las variables pueden cambiar de posici√≥n), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)
:::
:::

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}

La principal es que [**no permite la definici√≥n "al vuelo"**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .


De ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---

## Intento final: tibble

```{r}
tabla <- tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
                "IMC" = peso / (estatura^2))
tabla
```

Las tablas en formato `tibble` nos permitir√° una [**gesti√≥n m√°s √°gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformaci√≥n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya autom√°ticamente el n√∫mero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
tabla$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de p√°ginas web y documentos sencillos
:::



# Base de tidyverse: tidydata {#bloque-II}

[**Nuestra base de datos: tibble. Tidydata: un multiverso de datos limpios**]{style="color:#444442;"}

---


## R base vs Tidyverse

Si conoces alg√∫n otro lenguaje de programaci√≥n (o tienes gente cercana que programa) te extra√±ar√° que no vayamos a usar conceptos habituales como

-   [**Bucles for**]{.hl-yellow}: repetir un c√≥digo un n√∫mero fijo de iteraciones.

-   [**Bucles while**]{.hl-yellow}: repetir un c√≥digo hasta que se cumpla una condici√≥n

-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el c√≥digo en funci√≥n del valor de las variables.

. . .

Y es que con tidyverse, en la [**mayor√≠a de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles)

---

## ¬øQu√© es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

`{tidyverse}` es un [**¬´universo¬ª de paquetes**]{.hl-yellow} para garanatizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicogr√°ficamente sencillo de entender, basado en la idea de que [**nuestros datos est√°n limpios y ordenados (tidy)**]{.hl-purple}

---

## ¬øQu√© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaci√≥n de datos
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n
:::
:::

Tambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## ¬øQu√© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaci√≥n de datos
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n
:::
:::

Tambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## Filosof√≠a base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducido por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuraci√≥n
-   hacer m√°s [**sencillo**]{.hl-green} su manipulaci√≥n.
-   c√≥digo [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto ser√° entender qu√© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos est√°n estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**√∫nica columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**√∫nico valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**m√∫ltiples tablas**]{.hl-yellow} debemos tener una [**columna com√∫n**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Tuber√≠a (pipe)

En `{tidyverse}` ser√° clave el [**operador pipe (tuber√≠a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): ser√° una [**tuber√≠a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, ser√≠a

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::

¬†

. . .

::: callout-caution
## Apunte importante

Desde la versi√≥n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que depend√≠a del paquete `{magrittr}` (bastante problem√°tico).
:::

---

## Tuber√≠a (pipe)

La principal ventaja es que el [**c√≥digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas c√≥digo.

¬†

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

¬øPero qu√© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).

¬†

```{r}
library(tidyr)
table4a
```

¬†

[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
‚ùé Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) ‚Üí las columnas `1999` y `2000` en realidad deber√≠an ser en s√≠ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el a√±o y otra que guarde el valor de la variable de inter√©s en cada uno de esos a√±os. Y lo haremos con la funci√≥n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::

¬†

-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`

¬†

```{r}
table2
```

¬†

[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
‚ùé Cada [**observaci√≥n est√° dividido en dos filas**]{.hl-red} ‚Üí los [**registros con el mismo a√±o deber√≠an ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos ser√° lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
‚ùé Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos ser√° hacer uso de la funci√≥n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

F√≠jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deber√≠an ser variables num√©ricas. Para ello podemos a√±adir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el √∫ltimo ejemplo con la tabla `table5`


```{r}
table5
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
‚ùé Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y a√±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## üíª Tu turno {#tu-turno-6}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused",
               names_to = "income",
               values_to = "people")
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::


# Operaciones con filas {#filas-tidyverse}

[**Operaciones con filas en tidyverse**]{style="color:#444442;"}

---


## ¬øQu√© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: [**gram√°tica para depurar**]{.hl-yellow}
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaci√≥n de datos
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n
:::
:::

Tambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.


---

## Preprocesamiento: dplyr

Dentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuraci√≥n**]{.hl-yellow} de datos de datos.

::: columns
::: {.column width="60%"}
![](img/dplyr.png){width=450}
:::

::: {.column width="40%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::
:::

La idea es que el [**c√≥digo sea legible**]{.hl-yellow}, como si fuese una lista de instrucciones que al leerla nos diga de manera muy evidente lo que est√° haciendo.

---

## Hip√≥tesis: tidydata

::: columns
::: {.column width="50%"}
Toda la depuraci√≥n que vamos a realizar es sobre la [**hip√≥tesis de que nuestros datos est√°n en tidydata**]{.hl-yellow}
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
::::

Recuerda que en `{tidyverse}` ser√° clave el [**operador pipe (tuber√≠a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): ser√° una [**tuber√≠a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

Vamos a practicar con el dataset `starwars` del paquete cargado `{dplyr}`

```{r}
#| eval: false
library(tidyverse)
starwars
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

El m√°s simple es cuando [**filtramos registros**]{.hl-yellow} en base a alguna condici√≥n l√≥gica: con `filter()` se seleccionar√°n solo individuos que cumplan ciertas condiciones (muestreo no aleatorio por condiciones)


::: incremental
-   `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-yellow} que (`|> filter(variable == "a")`)
-   `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-yellow} que (`|> filter(variable < 3)`)
-   `>=`, `<=`: [**mayor o igual**]{.hl-yellow} o [**menor o igual**]{.hl-purple} que (`|> filter(variable >= 5)`)
-   `%in%`: valores [**pertenencen**]{.hl-yellow} a un listado de opciones (`|> filter(variable %in% c("azul", "verde"))`)
-   `between(variable, val1, val2)`: si los valores (continuos) [**caen dentro de un rango**]{.hl-yellow} de valores (`|> filter(between(variable, 160, 180))`)
:::

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¬øC√≥mo har√≠as para... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?

. . .

[**¬øQu√© tipo de variable es?**]{.hl-yellow} --> La variable `eye_color` es cualitativa as√≠ que est√° representada por textos

. . .

```{r}
#| echo: false
#| include: false
library(tidyverse)
```

```{r}
starwars |>
  filter(eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¬øC√≥mo har√≠as para... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?

. . .


```{r}
starwars |>
  filter(eye_color != "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¬øC√≥mo har√≠as para ... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color %in% c("blue", "brown"))
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

F√≠jate que `%in%` es equivalente a concatenar varios `==` con una conjunci√≥n o (`|`)

```{r}
starwars |>
  filter(eye_color == "blue" | eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¬øC√≥mo har√≠as para ... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?

. . .

[**¬øQu√© tipo de variable es?**]{.hl-yellow} --> La variable `height` es cuantitativa continua as√≠ que deberemos filtrar por rangos de valores (intervalos) --> usaremos `between()`

. . .

```{r}
starwars |>
  filter(between(height, 120, 160))
```


---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color == "brown" & species != "Human")
```


---

## Eliminar ausentes: drop_na()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  retirar_ausentes(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(var1, var2, ...)
```
:::
:::

Hay un filtro especial para una de las operaciones m√°s habituales en depuraci√≥n: [**retirar los ausentes**]{.hl-yellow}. Para ello podemos usar dentro de un filtro `is.na()`, que nos devuelve `TRUE/FALSE` en funci√≥n de si es ausente, o bien ...

. . .

Usar `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquier variable. M√°s adelante veremos como [**imputar esos ausentes**]{.hl-yellow} 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(mass, height)
```

```{r}
#| echo: false
starwars |>
  drop_na(mass, height, sex) |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na()
```

```{r}
#| echo: false
starwars |>
  drop_na() |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::
:::

---

## üíª Tu turno {#tu-turno-9a}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Selecciona del conjunto de starwars solo los personajes cuyo peso est√© entre 65 y 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter((species != "Human" & sex == "male" &
            between(height, 120, 170)) |
           eye_color %in% c("brown", "red"))
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Busca informaci√≥n en la ayuda de la funci√≥n `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con alg√∫n vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(str_detect(name, "Skywalker"))
```
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(posiciones)
```
:::
:::

A veces nos puede interesar realizar un [**muestreo no aleatorio discreccional**]{.hl-yellow}, o lo que es lo mismo, [**filtrar por posici√≥n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de √≠ndices**]{.hl-yellow}

. . .

::: columns
::: {.column width="50%"}
```{r}
#| eval: false

# fila 1
starwars |>
  slice(1)
```

```{r}
#| echo: false
starwars |> slice(1) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false

# filas de la 7 a la 9
starwars |>
  slice(7:9)
```

```{r}
#| echo: false
starwars |> slice(7:9) |> select(name:hair_color)
```
:::
:::

. . .

```{r}
#| eval: false

# filas 2, 7, 10 y 31
starwars |>
  slice(c(2, 7, 10, 31))
```

```{r}
#| echo: false
starwars |>
  slice(c(2, 7, 10, 31)) |> select(name:sex)
```

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_head(n = 2)
```

```{r}
#| echo: false
starwars |> slice_head(n = 2) |> select(name:hair_color)
```
:::

::: {.column width="\"50%"}
```{r}
#| eval: false
starwars |> slice_tail(n = 2)
```

```{r}
#| echo: false
starwars |> slice_tail(n = 2) |> select(name:hair_color)
```
:::
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`) que indicamos en `order_by = ...`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_min(mass, n = 2)
```

```{r}
#| echo: false
starwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_max(height, n = 2)
```

```{r}
#| echo: false
starwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)
```
:::
:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

El conocido como [**muestreo aleatorio simple**]{.hl-yellow} se basa en [**seleccionar individuos aleatoriamente**]{.hl-yellow}, de forma que cada uno tenga ciertas [**probabilidades**]{.hl-yellow} de ser seleccionado. Con `slice_sample(n = ...)` podemos extraer n registros aleatoriamente (a priori equiprobables).

```{r}
starwars |> slice_sample(n = 2)
```

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

Tambi√©n podremos indicarle la [**proporci√≥n de datos a samplear**]{.hl-yellow} (en lugar del n√∫mero) y si queremos que sea [**con reemplazamiento (que se puedan repetir)**]{.hl-yellow}.

```{r}
# 5% de registros aleatorios con reemplazamiento
starwars |> 
  slice_sample(prop = 0.05, replace = TRUE)

```


---


## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

Como dec√≠amos, ¬´aleatorio¬ª no es igual que ¬´equiprobable¬ª, as√≠ que podemos pasarle un [**vector de probabilidades**]{.hl-yellow}. Por ejemplo, vamos a forzar que sea muy improbable sacar una fila que no sean las dos primeras

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

. . .

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

---

## Par√©ntesis: sample()

La funci√≥n `slice_sample()` es simplemente una integraci√≥n de `{tidyverse}` de la funci√≥n b√°sica de `R` conocida como `sample()` que nos permite [**muestrear elementos**]{.hl-yellow}

. . .

Por ejemplo, vamos a [**muestrear 10 tiradas de un dado**]{.hl-yellow}, indic√°ndole

- [**soporte**]{.hl-purple} de nuestra variable aleatorio (valores permitidos en `x`)
- [**tama√±o**]{.hl-purple} muestral (`size`)
- [**reemplazamiento**]{.hl-purple} (si `TRUE` entonces pueden salir repetidas, como en el caso del dado)

```{r}
sample(x = 1:6, size = 10, replace = TRUE)
```



---

## üíª Tu turno {#tu-turno-9b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Selecciona solo los personajes que sean humanos y de ojos marrones, para despu√©s ordernarlos en altura descendente y peso ascendente.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Extrae 3 registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(n = 3)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Extrae el 10% de los registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(prop = 0.1)
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (m√°s pesados, m√°s probable)

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Selecciona los 3 personajes m√°s mayores.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_max(birth_year, n = 3)
```


:::



# Operaciones con columnas {#tidyverse-columnas}

[**Operaciones con columnas en tidyverse**]{style="color:#444442;"}

---


## Reordenar filas: arrange()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> ordenar(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(var1, var2, ...)
```
:::
:::

Tambi√©n podemos [**ordenar filas**]{.hl-yellow} en funci√≥n de alguna variable con `arrange()`

```{r}
#| eval: false
starwars |> arrange(mass)
```

```{r}
#| echo: false
starwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) 
```

. . .

Por [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(desc(height))
```

```{r}
#| echo: false
starwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(mass, desc(height))
```

```{r}
#| echo: false
starwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
:::

---

## Eliminar duplicados: distinct()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> sin_duplicados(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> distinct(var1, var2, ...)
```
:::
:::

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`.

```{r}
starwars |> distinct(sex)
```

. . .

Para mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.

```{r}
#| eval: false
starwars |> distinct(sex, .keep_all = TRUE)
```

```{r}
#| echo: false
starwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)
```

---

## A√±adir filas: bind_rows()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> encuadernar_filas(tibble2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> bind_rows(tibble2)
```
:::
:::

Por √∫ltimo, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)

```{r}
datos <-
  tibble("nombre" = c("javi", "laura"), "edad" = c(33, 50))
datos
```

. . .

```{r}
datos |> bind_rows(tibble("nombre" = c("carlos", NA), "cp" = c(28045, 28019)))
```

---

## üíª Tu turno {#tu-turno-10a}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Para saber que valores √∫nicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(hair_color) |> 
  distinct(hair_color)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù De los personajes que son humanos y miden m√°s de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 m√°s altos, y orden de mayor a menor peso. Devuelve la tabla.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es important√≠simo que el c√≥digo se entienda, por nuestro yo el futuro pero tambi√©n por la [**transparencia algor√≠tmica**]{.hl-yellow} hacia los dem√°s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 m√°s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es important√≠simo que el c√≥digo se entienda, por nuestro yo el futuro pero tambi√©n por la [**transparencia algor√≠tmica**]{.hl-yellow} hacia los dem√°s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 m√°s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es important√≠simo que el c√≥digo se entienda, por nuestro yo el futuro pero tambi√©n por la [**transparencia algor√≠tmica**]{.hl-yellow} hacia los dem√°s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 m√°s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es important√≠simo que el c√≥digo se entienda, por nuestro yo el futuro pero tambi√©n por la [**transparencia algor√≠tmica**]{.hl-yellow} hacia los dem√°s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 m√°s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen

La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es important√≠simo que el c√≥digo se entienda, por nuestro yo el futuro pero tambi√©n por la [**transparencia algor√≠tmica**]{.hl-yellow} hacia los dem√°s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 m√°s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::



## Selecci√≥n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La opci√≥n m√°s sencilla para [**seleccionar variables por nombre**]{.hl-yellow} es `select()`, dando como argumentos los nombres de columnas [**sin comillas**]{.hl-purple}.

```{r}
starwars |> select(name, hair_color)
```

---

## Selecci√≥n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La funci√≥n `select()` nos permite seleccionar varias variables a la vez, incluso [**concatenando sus nombres como si fuesen √≠ndices num√©ricos**]{.hl-yellow}

```{r}
#| eval: false
starwars |> select(name:eye_color) 
```

```{r}
#| echo: false
starwars |> select(name:eye_color) |> slice(1:4)
```

. . .

Y podemos [**deseleccionar columnas**]{.hl-yellow} con `-` delante

```{r}
#| eval: false
starwars |>  select(-mass, -(eye_color:starships))
```

```{r}
#| echo: false
starwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)
```

---

## Selecci√≥n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Tenemos adem√°s [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...

```{r}
#| eval: false
starwars |> select(mass, homeworld, everything())
```

```{r}
#| echo: false
starwars |> select(mass, homeworld, everything()) |> slice(1:4)
```

. . .

...y `last_col()` para referirnos a [**la √∫ltima columna**]{.hl-purple}.

```{r}
#| eval: false
starwars |> select(name:mass, homeworld, last_col())
```

```{r}
#| echo: false
starwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)
```

---

## Selecci√≥n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Tambi√©n podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresi√≥n regular**]{.hl-purple} (`matches()`).

```{r}
# variables cuyo nombre acaba en "color" y contengan sexo o g√©nero
starwars |> select(ends_with("color"), matches("sex|gender"))
```

---

## Selecci√≥n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Incluso podemos [**seleccionar por rango num√©rico**]{.hl-yellow} si tenemos variables con un prefijo y n√∫meros.

```{r}
datos <-
  tibble("semana1" = c(115, 141, 232), "semana2" = c(7, NA, 17),
         "semana3" = c(95, 162, NA), "semana4" = c(11, 19, 15),
         "semana5" = c(NA, 262, 190), "semana6" = c(21, 15, 23))
```

. . .

Con `num_range()` podemos seleccionar con un prefijo y una secuencia num√©rica.

```{r}
datos |> select(num_range("semana", 1:4))
```

---

## Selecci√≥n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Por √∫ltimo, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funci√≥n que devuelva un valor l√≥gico de tipo de dato.

```{r}
# Solo columnas num√©ricas o de texto
starwars |> select(where(is.numeric) | where(is.character))
```

---


## Mover columnas: relocate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  recolocar(var1, despues_de = var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  relocate(var1, .after = var2)
```
:::
:::

Para facilitar la [**recolocaci√≥n de variables**]{.hl-yellow} tenemos una funci√≥n para ello, `relocate()`, indic√°ndole en `.after` o `.before` [**detr√°s**]{.hl-purple} o [**delante**]{.hl-purple} de qu√© columnas queremos moverlas.

```{r}
starwars |> relocate(species, .before = name)
```

---

## Renombrar: rename()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> renombrar(nuevo = antiguo)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> rename(nuevo = antiguo)
```
:::
:::

A veces tambi√©n podemos querer [**modificar la ¬´metainformaci√≥n¬ª**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.

```{r}
starwars |> rename(nombre = name, altura = height, peso = mass)
```

---

## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


Si observas la salida de los `select()` [**sigue siendo una tabla tibble**]{.hl-yellow}, ya que nos preserva la naturaleza de nuestros datos.

```{r}
starwars |> select(name)
```

---


## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


A veces no querremos dicha estructura sino [**extraer literalmente la columna en un vector**]{.hl-yellow}, algo que podemos hacer con `pull()`

```{r}
starwars |> pull(name)
```


---


## üíª Tu turno {#tu-turno-10b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Filtra el conjunto de personajes y qu√©date solo con aquellos que en la variable `height` no tengan un dato ausente. Con los datos obtenidos del filtro anterior, selecciona solo las variables name, height, as√≠ como todas aquellas variables que CONTENGAN la palabra color en su nombre.

### [**Ejercicio 2**]{.hl-yellow}

üìù Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano

### [**Ejercicio 3**]{.hl-yellow}

üìù Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detr√°s de la variable de nombres.

### [**Ejercicio 4**]{.hl-yellow}

üìù Con los datos obtenidos del ejercicio anterior, comprueba cu√°ntas modalidades √∫nicas hay en la variable de color de pelo (sin usar `unique()`).

### [**Ejercicio 5**]{.hl-yellow}

üìù Del conjunto de datos originales, elimina las columnas de tipo lista, y tras ello elimina duplicados en la variable `eye_color`. Tras eliminar duplicados extrae dicha columna en un vector.


:::

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. 


. . . 

Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.

```{r}
starwars |> mutate(height_m = height / 100)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

Adem√°s con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}

```{r}
starwars |> 
  mutate(height_m = height / 100,
         IMC = mass / (height_m^2), .before = name)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funci√≥n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolver√° una constante**]{.hl-red}
:::

. . .

```{r}
starwars |> 
  mutate(constante = mean(mass, na.rm = TRUE), .before = name)
```

---

## Recategorizar: if_else()

Tambi√©n podemos combinar `mutate()` con la expresi√≥n de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condici√≥n**]{.hl-purple}, hace una cosa, en caso contrario otra.

```{r}
starwars |> 
  mutate(human = if_else(species == "Human", "Human", "Not Human"),
         .after = name) |> 
  select(name:mass)
```

---

## Recategorizar: case_when()

Para [**recategorizaciones m√°s complejas**]{.hl-yellow} tenemos `case_when()`, por ejemplo, para crear una categor√≠a de los personajes en funci√≥n de su altura.

```{r}
starwars |> 
  drop_na(height) |> 
  mutate(altura = case_when(height < 120 ~ "enanos",
                            height < 160 ~ "bajito",
                            height < 180 ~ "normal",
                            height < 200 ~ "alto",
                            TRUE ~ "gigante"), .before = name)
```

---

## üíª Tu turno {#tu-turno-11}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Selecciona solo las variables nombre, altura y as√≠ como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detr√°s de la variable de nombres.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color) |> 
  relocate(color_pelo, .after = nombre)
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Con los datos originales, comprueba cu√°ntas modalidades √∫nicas hay en la variable de color de pelo.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  distinct(hair_color) |> 
  nrow()
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Del dataset original, selecciona solo las variables num√©ricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(where(is.numeric) | where(is.character)) |> 
  mutate(under_18 = birth_year < 18)
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(auburn = str_detect(hair_color, "auburn"))
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(IMC = mass / ((height/100)^2),
         IMC_recat = case_when(species != "Human" ~ NA,
                               IMC < 18 ~ "delgadez",
                               IMC < 30 ~ "normal",
                               TRUE ~ "sobrepeso"),
         .after = name)
```

:::

---


## üê£ Caso pr√°ctico {#caso-11}


Haciendo uso de todo lo aprendido, vamos a proceder a [**crear una tabla con datos de beb√©s**]{.hl-yellow} de tama√±o `n = 20` en donde [**simulemos el sexo de los beb√©s y su peso**]{.hl-yellow}

. . .

1. Crea un `tibble` con dos columnas, una llamada `id_bebe` y otra llamada `sexo`. En el primer caso debe ir de 1 a 20. En el segundo caso, simula su sexo de manera que haya un 0.5 de probabilidad de `chico` y 0.5 de `chica`.


2. Conocido el sexo, crea una tercera columna llamada `peso` en la que simules dicho valor. Supondremos que para los chicos el peso sigue una distribuci√≥n $N(\mu = 3.266kg, \sigma = 0.514)$ y que para las chicas sigue una distribuci√≥n $N(\mu = 3.155kg, \sigma = 0.495)$.

. . .

```{r}
tb <- 
  tibble("id_bebe" = 1:20,
         "sexo" = sample(c("chico", "chica"), size = 20, replace = TRUE))
microbenchmark::microbenchmark(tb |> 
  mutate(peso =
           rnorm(n = 20, mean = if_else(sexo == "chico", 3.266, 3.155),
                 sd = if_else(sexo == "chico", 0.514, 0.495))), for (i in 1:20) { tb[i, 3] = ifelse(tb$sexo[i] == "chico", rnorm(n = 1, mean = 3.266, sd = 0.514), rnorm(n = 1, mean = 3.155, sd = 0.495)) }, times = 1e3)
```


# Res√∫menes {#summarise}

[**Summarise y group_by(). Contar y resumir: estad√≠sticas desagregadas por factores/grupos.**]{style="color:#444442;"}

---


## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estad√≠sticas. Empecemos por lo sencillo: [**¬øc√≥mo contar (frecuencias)?**]{.hl-yellow}

. . .

Cuando lo usamos en solitario `count()` nos devolver√° simplemente el n√∫mero de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**n√∫mero de elementos de cada modalidad**]{.hl-purple}.

```{r}
starwars |> count(sex)
```

---

## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Adem√°s si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolver√° el [**conteo ordenado**]{.hl-purple} (m√°s frecuentes primero).

```{r}
starwars |> count(sex, gender, sort = TRUE)
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Una de las [**funciones m√°s potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitir√° [**agrupar nuestros registros**]{.hl-yellow} previamente

```{r}
starwars |> 
  group_by(sex) |>
  count() |>
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificar√° las acciones futuras: las [**operaciones se aplicar√°n a cada subtabla por separado**]{.hl-purple}

. . .

Por ejemplo, imaginemos que queremos extraer el personaje m√°s alto con `slice_max()`.

```{r}
starwars |> slice_max(height)
```


---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

¬øY si queremos [**extraer el personaje m√°s alto pero...de cada uno de los sexos**]{.hl-yellow}?

. . .

```{r}
starwars |>
  group_by(sex) |> 
  slice_max(height) |> 
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

::: columns
::: {.column width="50%"}
![](img/tidydatatutor_1.jpg)
:::

::: {.column width="50%"}
![](img/tidydatatutor_2.jpg)
:::
:::

La web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |>
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |>
  ungroup()
```
:::
:::

::: callout-important
## Importante

Recuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada
:::

. . .

En la nueva versi√≥n de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`

```{r}
#| eval: false
starwars |> slice_max(height, by = sex)
```

```{r}
#| echo: false
starwars |> slice_max(height, by = sex) |> select(name:eye_color)
```

---

## Fila-a-fila: rowwise()

Una opci√≥n muy √∫til usada antes de una operaci√≥n tambi√©n es `rowwise()`: toda [**operaci√≥n que venga despu√©s se aplicar√° en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.

```{r}
notas <- tibble("mates" = c(7.5, 8, 9.1, 3),
                "lengua" = c(8, 6, 6.5, 9.2))
```

. . .

Si aplicamos la media directamente el valor ser√° id√©ntico ya que nos ha hecho la media global, pero nos gustar√≠a sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`

```{r}
notas |> 
  rowwise() |> 
  mutate(media_curso = mean(c(mates, lengua)))
```

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Por √∫ltimo tenemos `summarise()`, que nos permitir√° sacar res√∫menes estad√≠sticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.

```{r}
starwars |> 
  drop_na(height) |> 
  summarise(media_altura = mean(height))
```

. . .

::: callout-warning
## Cuidado

F√≠jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que est√© indicado.
:::

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Si adem√°s esto lo [**combinamos con la agrupaci√≥n**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas l√≠neas de c√≥digo puedes obtener [**estad√≠sticas desagreagadas**]{.hl-purple}

```{r}
starwars |> 
  drop_na(sex, height, mass) |> 
  summarise(media_altura = mean(height),
            media_peso = mean(mass),
            .by = sex)
```

---

## Resumir: reframe()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> reframe()
```
:::
:::

En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos m√°s de un valor por variable**]{.hl-yellow}.

::: columns
::: {.column width="50%"}
```{r}
#| warning: true
starwars |>
  drop_na(mass) |>
  summarise(quantile(mass))
```
:::

::: {.column width="50%"}
```{r}
starwars |>
  drop_na(mass) |>
  reframe(quantile(mass))
```
:::
:::

---

## Selectores: across()

Un truco es [**hacer uso de selectores**]{.hl-yellow} `across()` y `where()`. El primero nos permite [**actuar sobre varias columnas por nombre**]{.hl-purple} (con `mutate()` o `summarise()`)

```{r}
starwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)
```

. . .

El segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.

```{r}
starwars |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))
```

---

## üíª Tu turno {#tu-turno-11b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Calcula cu√°ntos personajes hay de cada especie, ordenados de m√°s a menor frecuencia.

```{r}
#| code-fold: true
#| eval: false
starwars |> count(species, sort = TRUE)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Tras eliminar ausentes en las variables de peso y estatura, a√±ade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass, height) |> 
  mutate(IMC = mass / ((height/100)^2)) |> 
  summarise(IMC_medio = mean(IMC), .by = sex)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Obt√©n el personaje m√°s joven por cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  slice_min(birth_year, by = sex)
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Obt√©n la edad del personaje m√°s joven y m√°s viejo de cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(birth_year) |>
  summarise(min(birth_year), max(birth_year), .by = sex)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Determina la cantidad de personajes en cada d√©cada (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  count(birth_decade = round(birth_year, -1))
```
:::

---

## üê£ Caso pr√°ctico {#caso-12}

Vamos antes a hacer un [**repaso de lo aprendido**]{.hl-yellow} en `{tidyverse}`

1. Carga la tabla billboard del paquete `{tidyr}`.

```{r}
#| code-fold: true
#| eval: false
billboard
```

2. Antes de nada, selecciona solo las [**primeras 52 semanas**]{.hl-yellow}. Tras ello convierte el dataset a [**tidydata**]{.hl-yellow} con los formatos y tipos adecuados para cada variable

. . .

3. Extrae la [**lista de artistas distintos**]{.hl-yellow} que aparecen en la tabla, incluyendo [**cu√°ntas veces**]{.hl-yellow} aparece cada uno.

. . .

4. Determina [**cu√°ntas canciones tiene cada artistal**]{.hl-yellow}

---

## üê£ Caso pr√°ctico

5. Determina las [**5 canciones que m√°s semanas**]{.hl-yellow} aparecen en la lista de √©xitos. 

. . .

6. Determina [**para cada artista la canci√≥n que m√°s semanas**]{.hl-yellow} aparece en la lista de √©xitos. 

. . .

7. Determina el [**artista con m√°s canciones**]{.hl-yellow} en la lista

. . .



---

## üê£ Caso pr√°ctico


8. Calcula la [**posici√≥n m√°s alta**]{.hl-yellow} en la que ha estado cada canci√≥n. Calcula la posici√≥n m√°s alta en la que ha estado un artista

. . .

9. Realiza un muestreo aleatorio estratificado, extrayendo el 50% de los datos pero manteniendo la proporci√≥n de datos entre los distintos cuatrimestres.


# Comunicar: Quarto {#quarto}

[**Comunicar resultados y material docente: rmd y Quarto**]{style="color:#444442;"}

---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

-   instalar [**Quarto**](https://quarto.org/docs/get-started/) (el ¬´nuevo¬ª `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::


---

## Comunicar: rmd y Quarto

Los archivos de extensi√≥n `.qmd` (o `.rmd`) nos permitir√°n f√°cilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, _cursivas_, etc) con un dise√±o legible.

. . .

-   [**Matem√°ticas (latex)**]{.hl-yellow}: lenguaje para escribir notaci√≥n matem√°tica como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**C√≥digo y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el c√≥digo que has ido realizando (no solo en `R`), con [**cajitas de c√≥digo llamadas chunks**]{.hl-purple}.

. . .

-   Im√°genes, [**gr√°ficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentaci√≥n sin salirte del entorno de programaci√≥n**]{.hl-yellow} en el que est√°s trabajando

De esta forma podr√°s analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarroll√≥ [**Quarto**]{.hl-yellow}, una versi√≥n mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco m√°s est√©tico y simple. Tienes toda la documentaci√≥n y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensi√≥n `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

:::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecer√°n varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento din√°mico, permite la interacci√≥n con el usuario, como una ¬´p√°gina web¬ª.
-   archivo `.doc` (nada recomendable)
:::
::::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**t√≠tulo**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

:::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}

Deber√≠as tener algo similar a la captura de la imagen con [**dos modos de edici√≥n**]{.hl-yellow}: `Source` (con c√≥digo, la opci√≥n recomendada hasta que lo domines) y `Visual` (m√°s parecido a un blog)

:::
::::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

## Cabecera de un qmd

![](img/quarto-prueba-html.png)

Deber√≠as haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Nuestro primer informe

:::: columns
::: {.column width="50%"}
![](img/quarto-example.png)

:::

::: {.column width="50%"}

Un fichero `.qmd` se [**divide b√°sicamente en tres partes**]{.hl-yellow}:

* [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

* [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble ast√©risco al inicio y final), cursivas (_cursivas_, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes a√±adir ecuaciones como $x^2$ (he escrito `$x^2$`, entre d√≥lares).

* [**C√≥digo R**]{.hl-yellow}

:::
::::

---

## Cabecera de un qmd

La [**cabecera est√°n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento:

:::: columns
::: {.column width="30%"}
![](img/quarto-cabecera.png)
:::

::: {.column width="70%"}

* `title` y `subtitle`: el t√≠tulo/subt√≠tulo del documento
* `author`: autor del mismo
* `date`: fecha
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes alg√∫n archivo de estilos
  * `toc`: si quieres √≠ndice o no
  * `toc-location`: posici√≥n del √≠ndice
  * `toc-title`: t√≠tulo del √≠ndice
  * `toc-depth`: profundidad del √≠ndice
* `editor`: si est√°s en modo visual o source.

:::
::::

---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No c√≥digo R.

:::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width=350}
![](img/quarto-prueba-html2.png){width=320}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una secci√≥n al inicio (`# Intro` y detr√°s por ej. la frase

> Este material ha sido dise√±ado por el profesor Javier √Ålvarez Li√©bana, docente en la Universidad Complutense de Madrid

Adem√°s al `Running Code` le a√±adiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servir√°n para crear [**ep√≠grafes (secciones)**]{.hl-yellow} en el documento


:::
::::


---

## √çndice de un qmd

:::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width=370}
![](img/quarto-indice-html2.png){width=370}
:::

::: {.column width="60%"}
Para que el [**√≠ndice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localizaci√≥n del √≠ndice y el t√≠tulo si quieres para probar).

:::
::::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:


:::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width=370}
![](img/quarto-texto-mejorado-html.png){width=370}
:::

::: {.column width="50%"}
* Vamos a a√±adir [**negrita al nombre**]{.hl-yellow} (poniendo ** al inicio y al final).

* Vamos a√±adir [**cursiva**]{.hl-yellow} a la palabra material (poniendo _ al inicio y al final).

* Vamos a√±adir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asoci√°ndolo al nombre de la Universidad. Para ello el t√≠tulo lo ponemos entre corchetes y justo detr√°s el enlace entre par√©ntesis `[¬´Universidad Complutense de Madrid¬ª](https://www.ucm.es)`

:::
::::

---

## C√≥digo en un qmd

Para [**a√±adir c√≥digo R**]{.hl-yellow} debemos crear nuestras [**cajas de c√≥digo llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir c√≥digo de casi cualquier lenguaje (y sus salidas).

&nbsp;

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width=470}
:::

::: {.column width="50%"}

Para incluir uno deber√° de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::

::::

---

## C√≥digo en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos c√≥digo R**]{.hl-yellow} como lo ven√≠amos haciendo hasta ahora en los scripts.

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width=410}
![](img/quarto-chunk-1-html.png){width=410}
:::

::: {.column width="50%"}

 Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho c√≥digo en nuestro `.qmd` (dentro de ese chunk)

```{r}
# C√≥digo R
x <- 1
y <- 2
x + y
```

:::

::::


---

## Etiquetando chunks


:::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width=400}
![](img/quarto-tag-chunks-html.png){width=400}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir c√≥digo.
:::
::::


---

## Ejecutando chunks

:::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width=400}
![](img/quarto-inline-html.png){width=380}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

* bot√≥n de [**play**]{.hl-yellow}: activa la [**ejecuci√≥n y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

* bot√≥n de [**rebobinar**]{.hl-yellow}: activa la [**ejecuci√≥n y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a √©l)

&nbsp;

Adem√°s podemos [**incluir c√≥digo R dentro de la l√≠nea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el c√≥digo R mostrando la variable).
:::
::::



---

## Personalizaci√≥n de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

* `#| echo: false`: [**ejecuta c√≥digo**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza c√≥digo**]{.hl-red} en la salida.

* `#| include: false`: [**ejecuta c√≥digo**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza c√≥digo**]{.hl-red} en la salida.

* `#| eval: false`: [**no ejecuta c√≥digo**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**s√≠ visualiza c√≥digo**]{.hl-green} en la salida.

* `#| message: false`: [**ejecuta c√≥digo**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

* `#| warning: false`: [**ejecuta c√≥digo**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

* `#| error: true`: [**ejecuta c√≥digo**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.


![](img/quarto-options-chunk.png){width=380}

Estas opciones podemos aplicarlas chunk a chunk o fijar los par√°metros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Organizando qmd

Adem√°s de texto y c√≥digo podemos introducir lo siguiente:

* [**Ecuaciones**]{.hl-yellow}: puedes a√±adir adem√°s ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuaci√≥n entre d√≥lares).

* [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

* [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[Secci√≥n](@nombre-seccion)`

---

## Gr√°ficas/im√°genes en qmd

:::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width=340}
![](img/quarto-fig-html.png){width=390}
:::

::: {.column width="50%"}
Por √∫ltimo, tambi√©n podemos [**a√±adir pies de gr√°ficas o im√°genes**]{.hl-yellow} a√±adiendo `#| fig-cap: "..."`
:::
::::

. . .

:::: columns
::: {.column width="65%"}
F√≠jate que el [**caption est√° en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes m√°s informaci√≥n en **<https://quarto.org/>**
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width=400}
:::
::::

---

## A√±adir estilos

:::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width=400}
![](img/quarto-estilos-html.png){width=400}
:::

::: {.column width="50%"}
Por √∫ltimo puedes a√±adir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Ten√©is disponible un archivo de estilos en <https://github.com/dadosdelaplace/seminario-R-biods>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
::::

---

## Generar diapositivas


El proceso es equivalente con tres cambios:

* [**Quarto presentation**]{.hl-yellow}: ahora en `File > New File` hay que hacer click en `Quarto Presentation`. La cabecera ahora ser√° ahora parecido a esto (entre otras personalizaciones posibles)

```{r}
#| eval: false
title: "Tidyverse y Quarto"
subtitle: "Seminario de tidyverse y Quarto para docencia e investigaci√≥n"
author: "Seminarios BioDS ‚Ä¢ curso 2023-2024"
affiliation: Facultad de Estudios Estad√≠sticos (UCM)
lang: es
format: 
  revealjs:
```

---

## Generar diapositivas


El proceso es equivalente con tres cambios:

* [**Separado de diapositivas**]{.hl-yellow}: para indicarle el cambio de diapositiva basta con escribir `. . .` (tres puntos separados por espacios y un salto de l√≠nea)

. . .

* [**Formato multicolumna**]{.hl-yellow}: el formato diapositivas permite el modo multicolumna (importante los espacios y no espacios del c√≥digo ya que no es `R` sino revealjs)


```{r}
#| eval: false
:::: columns
::: {.column width="40%"}
  algo en la primera columna (m√°s estrecha)
:::
::: {.column width="60%"}
  algo en la segunda columna (m√°s ancha)
:::
::::
```

# Importar y exportar {#importar}

[**Importar/exportar datos en R**]{style="color:#444442;"}

---

## Importar/exportar datos

Hasta ahora solo hemos usado datos cargados ya en paquetes pero muchas veces [**necesitaremos importar datos de manera externa**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos de manera muy sencilla en distintos formatos:


* [**Formatos nativos de R**]{.hl-yellow}: formatos `.rda`, `.RData` y `.rds`

. . .

* [**Datos rectangulares (tabulados)**]{.hl-yellow}: formatos `.csv` y `.tsv`

. . .

* [**Datos sin tabular**]{.hl-yellow}: formato `.txt`

. . .

* [**Datos en excel**]{.hl-yellow}: formatos `.xls` y `.xlsx`

. . .

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: formatos `.sas7bdat`, `.sav` y `.dat`

. . .

* [**Datos desde API**]{.hl-yellow}: Google Drive, aemet, catastro, twitter, spotify, etc



---

## Datos rectangulares: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene distintas funciones √∫tiles para la [**carga de datos rectangulares (sin formatear)**]{.hl-yellow}.

:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` cuyo [**separador sea la coma**]{.hl-purple}
* `read_csv2()`: [**punto y coma**]{.hl-purple}
* `read_tsv()`: [**tabulador**]{.hl-purple}.
* `read_table()`: [**espacio**]{.hl-purple}.
* `read_delim()`: funci√≥n gen√©rica para [**archivos delimitados por caracteres**]{.hl-purple}.


:::

::: {.column width="50%"}

![](img/data-import-readr.png)
:::
::::

Todos necesitan como **argumento la ruta del archivo** am√©n de **otros opcionales** (saltar o no cabecera, decimales, etc). Ver m√°s en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formateo**]{.hl-yellow} para pasar de un archivo plano (sin formato) a un tibble (en filas y columnas, con formato).

. . .

* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por coma**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el dataset `chickens.csv` (sobre pollos de dibujos animados, why not). Si te fijas en la salida nos proporciona el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)


El [**formato de las variables**]{.hl-yellow} normalmente lo har√° `read_csv()` de forma [**autom√°tica**]{.hl-yellow}, y podemos consultarlo con `spec()`

```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque lo haga normalmente bien de forma autom√°tica podemos [**especificar el formato expl√≠citamente**]{.hl-yellow} en `col_types = list()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo una la pondremos como cualitativa o factor). 


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_factor(), col_double(), col_character()))
chickens
```

---


## Datos tabulados (.csv, .tsv)

Incluso podemos indicar que [**variables que queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indic√°ndoselo en `col_select = ...`


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```


---


## Datos sin tabular (.txt)


Vamos a usar de nuevo `read_csv()` con el archivo `massey-rating.txt`.

```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```

. . .

Si te fijas nos interpreta todo como una sola columna: [**no tiene comas el archivo y no sabe por donde separar**]{.hl-yellow}

. . .


¬øQu√© sucede cuando el [**separador no es el correcto**]{.hl-red}?

---

## Datos sin tabular (.txt)

Para ello tenemos

* `read_csv2()` cuando el [**separador sea el punto y coma**]{.hl-yellow}, `read_tsv()` cuando el [**sea un tabulador**]{.hl-yellow} y `read_table()` cuando el [**sea un espacio**]{.hl-yellow}

* `read_delim()` en general

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


---

## Datos en excel (.xls, .xlsx)

Otro de los paquetes fundamentales de importaci√≥n ser√° el paquete  `{readxl}` para [**importar datos desde una Excel**]{.hl-yellow}. Tres funciones ser√°n claves:

* `read_xls()` espec√≠fica para `.xls`, `read_xlsx()` espec√≠fica para `.xlsx`
* `read_excel()`: para ambas

. . .

Vamos a importar `deaths.xlsx` con registros de fallecimientos de famosos

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths |> slice(1:8)
```

---

## Datos en excel (.xls, .xlsx)


```{r}
#| eval: false
deaths
```

```{r}
#| echo: false
deaths |> slice(1:8)
```

Algo por [**desgracia muy habitual**]{.hl-yellow} es que haya [**alg√∫n tipo de comentario o texto al inicio**]{.hl-red} del archivo, teniendo que [**saltarnos dichas filas**]{.hl-yellow}.

---

## Datos en excel (.xls, .xlsx)

Podemos [**saltarnos dichas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el n√∫mero de filas que nos saltamos)

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths |> slice(1:5)
```

---

## Datos en excel (.xls, .xlsx)

Adem√°s con `col_names = ...` podemos renombrar ya las columnas en la importaci√≥n (si [**proporcionamos nombres asume la 1¬™ l√≠nea ya como un dato**]{.hl-yellow})

```{r}
#| eval: false
#| code-line-numbers: "3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx",
            skip = 5,
            col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
                    col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths |> slice(1:7)
```
        
---

## Datos en excel (.xls, .xlsx)


En ocasiones las [**fechas de Excel est√°n mal formateadas**]{.hl-red} (sorpresa): podemos hacer uso de `convertToDate()` del paquete `{openxlsx}` para convertirlo


```{r}
#| eval: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths
```
   
```{r}
#| echo: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths |> slice(1:7)
```

---

## Datos en excel (.xls, .xlsx)

Tambi√©n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicarle la hoja**]{.hl-yellow} (bien por su nombre bien por su n√∫mero) usaremos el argumento `sheet = ...`

```{r}
#| eval: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```


```{r}
#| echo: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars |> slice(1:5)
```


. . .
 
Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```



---

## Desde SAS/STATA/SPSS

El paquete `{haven}` dentro de la √≥rbita tidyverse nos permitir√° [**importar archivos de los 3 software de pago m√°s importantes**]{.hl-yellow}: SAS, SPSS y Stata

```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---

## Exportar

De la misma manera que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportado en `.RData` (opci√≥n recomendada para variables guardadas en `R`). Recuerda que esta extensi√≥n [**solo se podr√° usar en `R`**]{.hl-yellow}. Para ello nos basta con usar `save(objeto, file = ruta)`

```{r}
tabla <- tibble("a" = 1:4, "b" = 1:4)
save(tabla, file = "./datos/tabla_prueba.RData")
rm(tabla) # eliminar
load("./datos/tabla_prueba.RData")
tabla
```

---


## Exportar

De la misma manera que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportado en `.RDS` (opci√≥n recomendada para variables guardadas en `R`). Recuerda que esta extensi√≥n [**solo se podr√° usar en `R`**]{.hl-yellow}. Para ello nos basta con usar `saveRDS(objeto, file = ruta)`

```{r}
saveRDS(tabla, file = "tabla.RDS") 
```

---

## Exportar

De la misma manera que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportado en `.csv`. Para ello nos basta con usar `write_csv(objeto, file = ruta)`

```{r}
write_csv(tabla, file = "./datos/tabla_prueba.csv")
read_csv(file = "./datos/tabla_prueba.csv")
```

---

## Exportar

De la misma manera que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportado en `.xlsx`. Para ello nos basta con usar `write.xlsx(objeto, file = ruta)` del paquete `{openxlsx}`

```{r}
library(openxlsx)
write.xlsx(tabla, file = "./datos/tabla_prueba.xlsx")
```

---

## Desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos de covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)


```{r}
#| eval: false
covid_datos <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_datos
```

```{r}
#| echo: false
covid_datos <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 700)
covid_datos
```

---

## Desde google drive

Otra opci√≥n disponible (sobre todo si trabajamos con otras personas que trabajan) es [**importar desde una hoja de c√°lculo Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`

La primera vez te pedir√° un permiso de tidyverse para interactuar con vuestro drive

```{r}
#| eval: false
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1n_UTbD93-oDJR2r-rsMNff5ro147NL_ZN_vYIA2eJ3Q/edit?usp=sharing")
google_sheet
```

---


## üíª Tu turno {#tu-turno-7}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù El dataset `who` que hemos usado en ejercicios anteriores, exp√≥rtalo a un formato nativo de `R` en la carpeta `datos` del proyecto

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who, file = "./datos/who.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Carga el dataset `who` pero desde la carpeta de datos (importa el archivo creado en el ejercicio anterior)

```{r}
#| code-fold: true
#| eval: false
load("./datos/who.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who, file = "./datos/who.csv")
who_data <- read_csv(file = "./datos/who.csv")

# excel
library(openxlsx)
write.xlsx(who, file = "./datos/who.xlsx")
who_data <- read_xlsx(path = "./datos/who.xlsx")

# sas y stata
library(haven)
write_sav(who, path = "./datos/who.sav")
who_data <- read_spss(path = "./datos/who.sav")

write_dta(who, path = "./datos/who.dta")
who_data <- read_dta(path = "./datos/who.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Repite la carga del `who.csv` pero solo selecciona ya en la carga las 4 primeras columnas

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who.csv",
           col_select = c("country", "iso2", "iso3", "year"))
```


:::



# Introducci√≥n a listas {#listas}

[**Uso de listas: paquete purrr**]{style="color:#444442;"}

---


## Introducci√≥n a listas

Veamos un peque√±o resumen de los datos que ya conocemos:

* [**vectores**]{.hl-yellow}: colecci√≥n de elementos de igual tipo. Pueden ser n√∫meros, caracteres o valores l√≥gicos, entre otros.

* [**matrices**]{.hl-yellow}: colecci√≥n BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* [**data.frame / tibble**]{.hl-yellow}: colecci√≥n BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} ser√°n [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heter√≥geneas (incluso una lista puede tener dentro a su vez otra lista).

---


## Paquete purrr

Una opci√≥n m√°s flexible y versatil que la familia `lapply` es hacer uso del paquete `{purrr}` ya cargado dentro del entorno `{tidyverse}`

```{r}
library(purrr)
```

Este paquete est√° pensado para imitar la [**programa funcional**]{.hl-yellow} de otros lenguajes orientados Big Data como Scala o Hadoop (de Google).

![](img/purrr.png)

---

## Paquete purrr

La funci√≥n m√°s simple de `{purrr}` es conocida como la funci√≥n `map()`, encargada de [**aplicar una funci√≥n a una lista de manera vectorial**]{.hl-yellow}, elemento a elemento.
. . .

Por ejemplo, con `map()` podemos [**"mapear" cada lista**]{.hl-yellow} y aplicar la funci√≥n ra√≠z cuadrada a cada elemento de la lista.

```{r}
x <- list("x1" = 1:4, "x2" = 11:20)
map(x, sqrt) 
```

. . .


::: callout-warning
## Be careful

Con `R` tenemos una vectorizaci√≥n autom√°tica cuando hablamos de vectores ya que trabaja elemento-a-elemento, pero por defecto, el [**output de `map` es una lista**]{.hl-yellow}.
:::


---

## Paquete purrr

Otro ejemplo: definamos dos distribuciones normales, con diferente $n$. ¬øC√≥mo **calcular la media de cada una** de manera inmediata? 

. . .

Las guardamos en una lista y aplicamos `map()`

```{r}
x <- list(rnorm(n = 1500, mean = 0, sd = 0.7),
          rnorm(n = 2800, mean = 2, sd = 1.5))
map(x, mean)
```

---

## Paquete purrr

Lo mismo si queremos usar cualquier otra funci√≥n que queramos definir nosotros mismos (por ejemplo, la media de los cuadrados)

```{r}
#| code-fold: true
map(x, function(x) { mean(x^2) })
```


---

## Paquete purrr

Adem√°s de ser  [**m√°s legible y eficiente**]{.hl-yellow}, con `{purrr}` podemos [**decidir el formato de salida de manera sencilla**]{.hl-yellow} 

* output como [**vector double**]{.hl-purple} con `map_dbl()`
* output como [**vector de enteros**]{.hl-purple} con `map_int()`
* output como [**vector de caracteres**]{.hl-purple} con `map_chr()`
* output como [**vector l√≥gico**]{.hl-purple} con `map_lgl()`

```{r}
map_dbl(x, mean)
map_chr(x, function(x) { glue::glue("Mean is {round(mean(x), 5)}") })
```

---

## Paquete purrr

```{r}
c(x[[1]][3], x[[2]][3])
```

Adem√°s si incluyes [**como argumento un n√∫mero**]{.hl-yellow} en lugar de una funci√≥n, nos devolver√° el [**i-√©simo elemento de la lista**]{.hl-yellow}.

```{r}
map_dbl(x, 3)
```


---


## Paquete purrr

Tambi√©n nos permite la opci√≥n de generalizarlo para funciones que necesiten  [**dos argumentos de entrada**]{.hl-yellow} (operaciones binarias) con `map2()`


```{r}
x <- list("a" = 1:3, "b" = 4:6)
y <- list("c" = c(-1, 4, 0), "b" = c(5, -4, -1))
map2(x, y, function(x, y) { x^2 + y^2})
```

---

## Paquete purrr

El output podemos tambi√©n obtenerlo en formato `tibble` a√±adiendo un `list_rbind()` o `list_cbind()` para [**concatenar los valores d euna lista en formato tabular**]{.hl-yellow}.


```{r}
x <- c("a", "b", "c")
y <- 1:3
map2(x, y, function(x, y) { tibble(x, y) }) |> list_rbind()
```

---

## Paquete purrr

Lo anterior se puede [**generalizar**]{.hl-yellow} con `pmap_xxx()` lo que nos permite aplicar funciones con [**m√∫ltiples argumentos**]{.hl-yellow}.


```{r}
x <- list(1, 1, 1)
y <- list(10, 20, 30)
z <- list(100, 200, 300)
pmap_dbl(list(x, y, z), sum)
```

---

## Paquete purrr

Dentro del paquete contamos con otro tipo de [**iteradores que no devuelven nada**] (solo side-effects) como es el caso de `walk()` (solo un argumento de entrada), `walk2()` (dos argumentos) and `pwalk()` (multiples argumentos), todos ellos [**con un return invisible**]{.hl-yellow}

```{r}
list("a" = 1:3, "b" = 4:6) |>
  map2(list("a" = 11:13, "b" = 14:16),
       function(x, y) { x + y }) |> 
  walk(print)
```

---

## Paquete purrr

Recientemente se ha desarrollado `{loopurrr}`, un paquete que permite la traducci√≥n con `as_loop()` de lenguaje funcional en `{purrr}` a bucles para poder entender mejor lo que hace (ver m√°s en <https://timteafan.github.io/loopurrr/>)


```{r}
#| eval: false
# remotes::install_github("TimTeaFan/loopurrr")
library(loopurrr)
x <- list(1, c(1:2), c(1:3))
x |>
  map(sum) |>  
  as_loop()
```


# Joins

[**Cruzando datos**]{style="color:#444442;"}


## Relacionando datos

Al trabajar con datos [**no siempre tendremos la informaci√≥n en una sola tabla**]{.hl-yellow} y a veces nos interesar√° cruzar la informaci√≥n de distintas fuentes.

. . .

Para ello usaremos un cl√°sico de todo lenguaje que maneja datos: los famosos [**join**]{.hl-yellow}, una herramienta que nos va a permitir [**cruzar una o variables tablas**]{.hl-yellow}, haciendo uso de una [**columna identificadora**]{.hl-yellow} de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo _join_ por la columna `DNI`).

---

## Relacionando datos


```{r}
#| eval: false
tabla_1 |>
  xxx_join(tabla_2, by = id)
```

* `inner_join()`: solo sobreviven los [**registros con id en ambas**]{.hl-yellow} tablas.

* `full_join()`: mantiene [**todos los registros de ambas**]{.hl-yellow} tablas.

* `left_join()`: mantiene [**todos los registros de la primera tabla**]{.hl-yellow}, y busca cuales tienen id tambi√©n en la segunda (en caso de [**no tenerlo se rellena con NA**]{.hl-yellow} los campos de la 2¬™ tabla).

* `right_join()`: mantiene [**todos los registros de la segunda tabla**]{.hl-yellow}, y busca cuales tienen id tambi√©n en la primera.

![](img/sql-joins.jpg)


---

## Relacionando datos

Vamos a probar los distintos joins con un ejemplo sencillo

```{r}
tb_1 <- tibble("key" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

:::: columns
::: {.column width="50%"}

```{r}
tb_1
```

:::

::: {.column width="50%"}

```{r}
tb_2
```

:::
::::

---

## Left join

Imagina que queremos [**incorporar**]{.hl-yellow} a `tb_1` la [**informaci√≥n de la tabla_2**]{.hl-yellow}, identificando los registros por la columna key (indicando con `by = "key"` la columna por la que tiene que cruzar): queremos mantener todos los registros de la primera tabla y buscar cuales tienen id (mismo valor en `key`) tambi√©n en la segunda tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1  |> 
  left_join(tb_2, by = "key")
```

:::
::: {.column width="50%"}


![](img/left_join.jpg)


:::
::::

---

## Left join

```{r}
tb_1 |> 
  left_join(tb_2, by = "key")
```

F√≠jate que los [**registros de la primera cuya key no ha encontrado en la segunda**]{.hl-yellow} les ha dado el valor de [**ausente**]{.hl-yellow}.

---

## Right join

El `right_join()` realizar√° la operaci√≥n contraria: vamos ahora a [**incorporar**]{.hl-yellow} a `tb_2` la [**informaci√≥n de la tabla_2**]{.hl-yellow}, identificando los registros por la columna key (indicando con `by = "key"` la columna por la que tiene que cruzar): queremos mantener todos los registros de la segunda y buscar cuales tienen id (mismo valor en `key`) tambi√©n en la primera tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

:::

::: {.column width="50%"}

![](img/right_join.jpg)

:::
::::


---

## Right join


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

F√≠jate que ahora los [**registros de la segunda cuya key no ha encontrado en la primera**]{.hl-yellow} son los que les ha dado el valor de [**ausente**]{.hl-yellow}.

---


## Claves y sufijos

Las columnas clave que usaremos para el cruce [**no siempre se llamar√°n igual**]{.hl-yellow}.

```{r}
tb_1 <- tibble("key_1" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

. . .

* `by = c("key_2" = "key_2")`: le indicaremos en qu√© columna de cada tabla est√°n las claves por las que vamos a cruzar.

:::: columns
::: {.column width="50%"}

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

```{r}
# Right
tb_1  |> 
  right_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::

---

## Claves y sufijos

Adem√°s podemos [**cruzar por varias columnas a la vez**]{.hl-yellow} (interpretar√° como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`. Modifiquemos el ejemplo anterior

```{r}
tb_1 <- tibble("k_11" = 1:3, "k_12" = c("a", "b", "c"),  "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("k_21" = c(1, 2, 4), "k_22" = c("a", "b", "e"), "val_y" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2,
            by = c("k_11" = "k_21", "k_12" = "k_22"))
```


---

## Claves y sufijos

Tambi√©n podr√≠a suceder que al cruzar dos tablas, haya [**columnas de valores que se llamen igual**]{.hl-yellow}


```{r}
tb_1 <- tibble("key_1" = 1:3, "val" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

F√≠jate que [**por defecto nos a√±ade los sufijos**]{.hl-yellow} `.x` y `.y` para indicarnos de que tabla vienen.

---

## Claves y sufijos


Dicho [**sufijo podemos especific√°rselo**]{.hl-yellow} en el argumento opcional `suffix = ...`, que nos permita [**distinguir las variables**]{.hl-yellow} de una tabla y de otra.


```{r}
# Left
tb_1 |>
  left_join(tb_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla2"))
```


---

## Full join

Los dos anteriores casos forman lo que se conoce como [**outer joins**]{.hl-yellow}: cruces donde se mantienen observaciones que salgan en al menos una tabla. El tercer outer join es el conocido como `full_join()` que nos [**mantendr√° las observaciones de ambas**]{.hl-yellow} tablas, [**a√±adiendo las filas**]{.hl-yellow} que no casen con la otra tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  full_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/full_join.jpg)

:::
::::


---

## Inner join

Frente a los outer join est√° lo que se conoce como [**inner join**]{.hl-yellow}, con `inner_join()`: un cruce en el que solo se mantienen las [**observaciones que salgan en ambas tablas**]{.hl-yellow}, solo mantiene aquellos registros matcheados.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/inner_join.png)


:::
::::

---

## Inner join

F√≠jate que en t√©rminos de registros, `inner_join` si es conmutativa, **nos da igual el orden de las tablas**: lo √∫nico que cambia es el orden de las columnas que a√±ade.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}


```{r}
tb_2 |> 
  inner_join(tb_1, by = c("key_2" = "key_1"))
```

:::
::::

---

## Anti/semi join

Por √∫ltimo tenemos dos herramientas interesantes para [**filtrar (no cruzar) registros**]{.hl-yellow}: `semi_join()` y `anti_join()`. El [**semi join**]{.hl-yellow} nos deja en la [**primera tabla los registros que cuya clave est√° tambi√©n en la segunda**]{.hl-yellow} (como un inner join pero sin a√±adir la info de la segunda tabla). Y el segundo, los anti join, hace justo lo contrario (aquellos que no est√°n).


:::: columns
::: {.column width="50%"}

```{r}
# semijoin
tb_1 |> 
  semi_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}

```{r}
# antijoin
tb_1 |> 
  anti_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---


## üíª Tu turno {#tu-turno-16}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerol√≠neas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorol√≥gicos horarios de las estaciones LGA, JFK y EWR.

---

## üíª Tu turno {#tu-turno-16}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Del paquete `{nycflights13}` cruza la tabla `flights` con `airlines`. Queremos mantener todos los registros de vuelos, a√±adiendo la informaci√≥n de las aerol√≠neas a la tabla de aviones.

```{r}
#| eval: false
#| code-fold: true
flights_airlines <-
  flights |> 
  left_join(airlines, by = "carrier")
flights_airlines
```

### [**Ejercicio 2**]{.hl-yellow}

üìù A la tabla obtenida del cruce del apartado anterior, cruza despu√©s con los datos de los aviones en `planes`, pero incluyendo solo aquellos vuelos de los que tengamos informaci√≥n de sus aviones (y viceversa). 


```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum")
flights_airlines_planes
```


### [**Ejercicio 3**]{.hl-yellow}

üìù Repite el ejercicio anterior pero conservando ambas variables `year` (en una es el a√±o del vuelo, en la otra es el a√±o de construcci√≥n del avi√≥n), y distingui√©ndolas entre s√≠



```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum",
             suffix = c("_flight", "_build_aircraft"))
flights_airlines_planes
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Al cruce obtenido del ejercicio anterior incluye la longitud y latitud de los aeropuertos en `airports`, distinguiendo entre la latitud/longitud del aeropuerto en destino y en origen.

```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes %>%
  left_join(airports %>% select(faa, lat, lon),
            by = c("origin" = "faa")) |> 
  rename(lat_origin = lat, lon_origin = lon) |> 
  left_join(airports %>% select(faa, lat, lon),
            by = c("dest" = "faa")) |> 
  rename(lat_dest = lat, lon_dest = lon)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Filtra de `airports` solo aquellos aeropuertos de los que salgan vuelos. Repite el proceso filtrado solo aquellos a los que lleguen vuelos

```{r}
#| eval: false
#| code-fold: true
airports |> 
  semi_join(flights, by = c("faa" = "origin"))
airports |> 
  semi_join(flights, by = c("faa" = "dest"))
```


### [**Ejercicio 6**]{.hl-yellow}

üìù ¬øDe cu√°ntos vuelos no disponemos informaci√≥n del avi√≥n? Elimina antes los vuelos que no tengan identificar (diferente a NA) del avi√≥n


```{r}
#| eval: false
#| code-fold: true
flights |> 
  drop_na(tailnum) |>
  anti_join(planes, by = "tailnum") |>
  count(tailnum, sort = TRUE) # de mayor a menor ya de paso
```

:::

# Factores

[**Trabajando con variables cualitativas**]{style="color:#444442;"}

---


## Factores

En el caso de las [**variables cualitativas**]{.hl-yellow}, llamaremos  **niveles o modalidades** a los **diferentes valores** que pueden tomar estos datos. Por ejemplo, en el caso de la variable `sex` del conjunto `starwars`, tenemos 4 niveles permitidos: `female`, `hermaphroditic`, `male` y `none` (am√©n de datos ausentes).

```{r}
starwars |> count(sex)
```


---

## Factores

Este tipo de variables se conocen en `R` como [**factores**]{.hl-yellow}. Y el paquete fundamental para tratarlos es `{forcats}` (del entorno `{tidyverse}`). 


![](./img/factors.jpg)

---

## Factores

Este paquete nos permite fijar los [**niveles**]{.hl-yellow} (guardados internamente como `levels`) que toma una determinada variable categ√≥rica, d√°ndoles un [**tratamiento diferente a las cadena de texto normales**]{.hl-yellow}.

. . .

Veamos un ejempo sencillo definiendo una variable `estado` que tome los valores `"sano"`, `"leve"` y `"grave"` de la siguiente manera.

```{r}
estado <-
  c("leve", "grave", "sano", "sano", "leve", "sano", "sano", "grave",
    "grave", "leve", "grave", "sano", "sano")
estado
```

La variable `estado` actualmente es de [**tipo texto**]{.hl-yellow}, de tipo `chr`, algo que podemos comprobar con `class(estado)`.

```{r}
class(estado)
```

---

## Factores

Desde un punto de vista estad√≠stico y computacional, para `R` esta variable ahora mismo ser√≠a equivalente una variable de nombres. Pero estad√≠sticamente [**no es lo mismo una variable con nombres**]{.hl-yellow} (que identifican muchas veces el registro) que una variable categ√≥rica como estado que [**solo puede tomar esos 3 niveles**]{.hl-yellow}. ¬øC√≥mo [**convertir a factor**]{.hl-yellow}?

. . .

Haciendo uso de la funci√≥n `as_factor()` del paquete `{forcats}`.

```{r}
library(tidyverse)
estado_fct <- tibble(paciente = 1:length(estado),
                     estado = as_factor(estado))
estado_fct
```

---

## Factores


No solo ha cambiado la clase de la variable sino que ahora, debajo del valor guardado, nos aparece la frase `Levels: grave leve sano`: son las [**modalidades o niveles**]{.hl-yellow} de nuestra cualitativa. 

&nbsp;

Imagina que ese d√≠a en el hospital no tuvi√©semos a **nadie en estado grave**: aunque ese d√≠a nuestra variable no tome dicho valor, el estado `grave` es un [**nivel permitido en la base de datos**]{.hl-yellow}, as√≠ que aunque lo eliminemos, por ser un factor, el nivel permanece (no lo tenemos ahora pero es un nivel permitido).


```{r}
estado_fct |> 
  filter(estado %in% c("sano", "leve")) |> 
  pull(estado)
```

---

## Factores


Con `factor()` podemos [**especificar expl√≠citamente**]{.hl-yellow} los nombres de las modalidades, incluso si son nominales u [**ordinales**]{.hl-yellow}

```{r}
estado_fct <-
  tibble(paciente = 1:length(estado),
         estado = factor(estado, ordered = TRUE))
estado_fct |> pull(estado)
```

---

## Factores


Con  `levels = ...` podemos indicarle expl√≠citamente el [**orden de las modalidades**]{.hl-yellow}

```{r}
estado_fct <-
  tibble(paciente = 1:length(estado),
         estado = factor(estado,
                         levels = c("sano", "leve", "grave"),
                         ordered = TRUE))
estado_fct |> pull(estado)
```



---

## Factores


:::: columns

::: {.column width="50%"}

Si queremos indicarle que [**elimine un nivel no usado**]{.hl-yellow} en ese momento (y que queremos excluir de la definici√≥n) podemos hacerlo con `fct_drop()`

:::


::: {.column width="50%"}

![](img/drop_factor.jpg)

:::
::::

```{r}
estado_fct |> 
  filter(estado %in% c("sano", "leve")) |> 
  mutate(estado = fct_drop(estado)) |> 
  pull(estado)
```

---

## Factores

:::: columns

::: {.column width="50%"}

Al igual que podemos eliminar niveles podemos [**ampliar los niveles existentes**]{.hl-yellow} (aunque no existan datos de ese nivel en ese momento) con `fct_expand()`

:::

::: {.column width="50%"}

![](./img/factor_expand.jpg)

:::
::::

```{r}
estado_fct |> 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) |> 
  pull(estado)
```

---

## Factores

:::: columns

::: {.column width="50%"}

Adem√°s con `fct_explicit_na()` podemos [**asignar un nivel a los valores**]{.hl-yellow} para que sea incluido dicho nivel en los an√°lisis y visualizaciones.

:::

::: {.column width="50%"}

![](./img/factor_explicit.jpg)

:::
::::

```{r}
fct_explicit_na(factor(c("a", "b", NA)))
```

---

## Factores


Incluso una vez definidos podemos [**reordenar los n√≠veles**]{.hl-yellow} con `fct_relevel()`


```{r}
estado_fct_expand <- 
  estado_fct |> 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) |> 
  pull(estado)

estado_fct_expand |>
  fct_relevel(c("fallecido", "leve", "sano", "grave", "UCI"))
  
```


---

## Factores

:::: columns

::: {.column width="50%"}

Esta forma de trabajar con variables cualitativas nos permite dar una [**definici√≥n te√≥rica**]{.hl-yellow} de nuestra base de datos, pudiendo incluso contar valores que a√∫n no existen (pero que podr√≠an), haciendo uso de `fct_count()`

:::

::: {.column width="50%"}

![](./img/fct_count.jpg)

:::
::::

```{r}
estado_fct |> 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) |> 
  pull(estado) |> 
  fct_count()
```


---

## Factores


Los n√≠veles tambi√©n podemos [**ordenarlos por frecuencia**]{.hl-yellow} con `fct_infreq()`

```{r}
estado_fct |> 
  mutate(estado = fct_infreq(estado)) |> 
  pull(estado) |> 
  fct_count()
```

---

## Factores


A veces querremos [**agrupar niveles**]{.hl-yellow}, por ejemplo, no permitiendo niveles que [**no sucedan un m√≠nimo de veces**]{.hl-yellow} con `fct_lump_min(.., min = ..)` (las observaciones que no lo cumplan ir√°n a un **nivel gen√©rico** llamado `Other`, aunque se puede cambiar con el argumento `other_level`). 

:::: columns

::: {.column width="50%"}


```{r}
estado_fct |> 
  pull(estado) |> 
  fct_lump_min(min = 4)
```

:::

::: {.column width="50%"}


```{r}
estado_fct |> 
  pull(estado) |> 
  fct_lump_min(min = 4,
               other_level = "otros")
```

:::
::::

---

## Factores


Podemos hacer algo equivalente pero en funci√≥n de su [**frecuencia relativa**]{.hl-yellow} con `fct_lump_prop()`.


```{r}
estado_fct |> 
  pull(estado) |> 
  fct_lump_prop(prop = 0.4,
                other_level = "otros")
```

---


## Factores

Esto lo podemos aplicar a nuestros conjuntos de datos para [**recategorizar variables**]{.hl-yellow} de forma muy r√°pida.

```{r}
starwars |> 
  drop_na(species) |> 
  mutate(species =
           fct_lump_min(species, min = 3,
                        other_level = "Otras")) |> 
  count(species)
```

---

## Factores

Con `fct_reorder()` podemos tambi√©n indicar que queremos [**ordenar los factores**]{.hl-yellow} en funci√≥n de una funci√≥n aplicada a otra variable.


```{r}
starwars_factor <- 
  starwars |> 
  drop_na(height, species) |> 
  mutate(species =
           fct_lump_min(species, min = 3,
                        other_level = "Otras"))
```

:::: columns

::: {.column width="50%"}

```{r}
starwars_factor |> pull(species)
```

:::



::: {.column width="50%"}

```{r}
starwars_factor |>
  mutate(species = fct_reorder(species, height, mean)) |> 
  pull(species)
```

:::
::::

---

## üíª Tu turno {#tu-turno-14}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Dada la variable `meses` definida debajo (definida como un vector de caracteres), convierte dicha variable a factor (solo eso)

```{r}
meses <- c("Ene", "Feb", "Mar", "Abr")
```

```{r}
#| eval: false
#| code-fold: true
meses <- c("Ene", "Feb", "Mar", "Abr")
meses_fct <- as_factor(meses)
meses_fct
```
  
### [**Ejercicio 2**]{.hl-yellow}

üìù Dada la variable `meses` definida debajo convierte dicha variable a factor pero indicando los niveles de forma correcta.

```{r}
meses <- c(NA, "Abr", "Ene", "Oct", "Jul", "Ene", "Sep", NA, "Feb", "Dic",
           "Jul", "Mar", "Ene", "Mar", "Feb", "Abr", "May", "Oct", "Sep",  NA,
           "Dic", "Jul", "Nov", "Feb", "Oct", "Jun", "Sep", "Oct", "Oct", "Sep")
```

```{r}
#| eval: false
#| code-fold: true
meses <- c(NA, "Abr", "Ene", "Oct", "Jul", "Ene", "Sep", NA, "Feb", "Dic",
           "Jul", "Mar", "Ene", "Mar", "Feb", "Abr", "May", "Oct", "Sep",  NA,
           "Dic", "Jul", "Nov", "Feb", "Oct", "Jun", "Sep", "Oct", "Oct", "Sep")

# Orden de niveles correcto e incluimos agosto aunque no haya
meses_fct <-
  factor(meses,
         levels = c("Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"))
meses_fct
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Cuenta cuantos valores hay de cada mes pero teniendo en cuenta que son factores (quiz√°s haya niveles sin ser usados y de los que deber√≠a obtener un 0).

```{r}
#| eval: false
#| code-fold: true
meses_fct |> fct_count()
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Dado que hay ausentes, indica que los ausentes sea un decimotercer nivel etiquetado como "ausente".

```{r}
#| eval: false
#| code-fold: true
meses_fct <- 
  meses_fct |>
  fct_explicit_na(na_level = "ausente")
meses_fct
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Elimina los niveles no usados.

```{r}
#| eval: false
#| code-fold: true
meses_fct <- 
  meses_fct |>
  fct_drop()
meses_fct
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Ordena los niveles por frecuencia de aparici√≥n.
  
```{r}
#| eval: false
#| code-fold: true
meses_fct |> 
  fct_infreq()
```


### [**Ejercicio 7**]{.hl-yellow}

üìù Agrupa niveles de forma que todo nivel que no aparezca al menos el 7% de las veces se agrupe en un nivel llamado "otros meses"

```{r}
#| eval: false
#| code-fold: true
meses_fct <-
  meses_fct |> 
  fct_lump_prop(prop = 0.07, other_level = "otros")
meses_fct
```

:::


# El mundo Github

[**Trabajar ordenados, publicar resultados, replicabilidad de lo realizado**]{style="color:#444442;"}

---

## ¬øQu√© es Github?

[**GitHub**]{.hl-yellow} es la plataforma colaborativa m√°s conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}

. . .

-   [**¬øQu√© es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programaci√≥n colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.

. . .

-   [**¬øQu√© es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servir√° no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcci√≥n de nuestros proyectos de c√≥digo.

. . .

::: callout-important
## Importante

Desde el 4 de junio de 2018 Github es de Microsoft (ergo el c√≥digo que subas tambi√©n)
:::

---

## Visi√≥n general

Tras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un c√≠rculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto

::: columns
::: {.column width="55%"}
![](img/github_1.png)
:::

::: {.column width="45%"}
-   [**Edit profile**]{.hl-purple}: nos permite a√±adir una [**descripci√≥n y foto de perfil**]{.hl-yellow}.

-   [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizar√° nuestra actividad**]{.hl-yellow} a lo largo del tiempo.

-   [**Repositories**]{.hl-purple}: el c√≥dugo ser√° subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.
:::
:::

---

## Primer uso: consumidor

Antes de aprender como crear repositorios, Github tambi√©n nos servir√° para

-   [**Acceder a c√≥digo**]{.hl-purple} ajeno
-   [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos

. . .

-   [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente ¬´amplio¬ª para poder ser subido como paquete.

El c√≥digo de paquetes que no tengamos subido en CRAN podremos [**instalarlo como c√≥digo desde Github**]{.hl-yellow}

---

## Instalar desde Github

Por ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya √∫nica funci√≥n es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**√°lbumes de m√∫sica urbana**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/perrreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="360"}
:::
:::

. . .

Para ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitir√° la instalaci√≥n desde Github

```{r}
#| eval: false
install.packages("devtools")
```

---

## Instalar desde Github

Las [**instrucciones de instalaci√≥n**]{.hl-yellow} suelen venir detalladas en la portada del repositorio

::: columns
::: {.column width="50%"}
![](img/install_perreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="310"}
:::
:::

. . .

En la mayor√≠a de casos bastar√° con la funci√≥n `install_github()` (del paquete que acabamos de instalar), pas√°ndole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin "github.com/").

```{r}
#| eval: false
devtools::install_github("jbgb13/peRReo")
```

Ya puedes perrear con ggplot ;)

---

## Descargar desde Github

La mayor√≠a de veces lo que subamos no ser√° un paquete de R como tal sino que [**subiremos un c√≥digo m√°s o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.

Por ejemplo, vamos a descargarnos los scripts de dataviz que han subido desde el [Centre d'Estudis d'Opini√≥](https://github.com/ceopinio/bop-grafics)

![](img/ceo_github.png)

---

## Ideal

![](img/abogados_simpson.jpeg){width="600"}

[**¬øLo ideal?**]{.hl-purple} Tener dos tipos de repositorios

-   Una [**colecci√≥n de repositorios p√∫blicos (producci√≥n)**]{.hl-yellow} donde hacer transparente el c√≥digo y los datos ([**ya validados**]{.hl-purple}), coordinado por un n¬∫ reducido de personas.

-   Una [**colecci√≥n de repositorios privados (desarrollo)**]{.hl-yellow} donde est√© todo el equipo colaborando y donde se haga el [**trabajo del d√≠a**]{.hl-purple}, con trazabilidad interna.

---

## Nuestro primer repositorio

Vamos a [**crear nuestro primero repositorio**]{.hl-yellow} que servir√° adem√°s como [**carta de presentaci√≥n**]{.hl-yellow} de nuestro perfil en Github.

1.  [**Repositories**]{.hl-purple}: hacemos click en las pesta√±a de Repositories.

2.  [**New**]{.hl-purple}: hacemos click en el [**bot√≥n verde New**]{.hl-green} para crear un nuevo repositorio

![](img/new_repo.png)

---

## Nuestro primer repositorio

-   [**Repository name**]{.hl-purple}: el [**nombre del repositorio**]{.hl-yellow}. En este caso vamos a crear un repositorio muy concreto: el nombre debe [**coincidir exactamente con tu nombre de usuario**]{.hl-yellow}

-   [**Description**]{.hl-purple}: descripci√≥n de tu repositorio. En este caso ser√° un repo de presentaci√≥n.

![](img/repo_init_1.png)

---

## Nuestro primer repositorio

-   [**Public vs private**]{.hl-purple}: con cada repositorio tendremos la opci√≥n de hacer el repositorio

    -   [**p√∫blico**]{.hl-purple}: todos los usuarios podr√°n ver el c√≥digo as√≠ c√≥mo la trazabilidad de su desarrollo (qu√© se a√±ade y cu√°ndo). Es para m√≠ la opci√≥n m√°s recomendable cuando quieres darle [**visibilidad y transparencia**]{.hl-yellow} a tu trabajo
    -   [**privado**]{.hl-purple}: solo tendr√°n acceso al repositorio aquellos usuarios a los que se lo permitas. No se podr√° visualizar ni instalar nada de √©l fuera de Github.

![](img/repo_init_2.png)

En este caso concreto, dado que ser√° un repositorio de presentaci√≥n, lo [**haremos p√∫blico**]{.hl-yellow}.

---

## Nuestro primer repositorio

-   [**Add a README file**]{.hl-purple}: un README file ser√° el archivo donde incluiremos las [**instrucciones y detalles de uso**]{.hl-yellow} a los dem√°s (en el caso de `{peRReo}` era el archivo que conten√≠a los detalles de instalaci√≥n)

![](img/repo_init_3.png)

De momento [**ignoraremos los dem√°s campos**]{.hl-red} para este primer repositorio.

---

## Nuestro primer repositorio

![](img/repo_init_1.png)

Por defecto Github asume que este repositorio, con el [**mismo nombre que nuestro usuario**]{.hl-yellow} ser√° el repositorio que querremos que se presente de inicio cuando alguien entra en nuestro perfil, y ser√° el repositorio donde \[**incluir en el README.md**\] una presentaci√≥n de nosotros y un √≠ndice de tu trabajo (si quieres).

---

## Nuestro primer repositorio

![](img/profile_github_md.png)

F√≠jate que ahora en nuestra [**portada tenemos dicho README.md**]{.hl-yellow} que podemos personalizar a nuestro gusto haciendo uso de [**html y markdown**]{.hl-yellow}.

Aqu√≠ puedes ver [**algunos ejemplos de README.MD**](https://github.com/matiassingers/awesome-readme)

---

## Repo de c√≥digo

Una vez que tenemos nuestro README de presentaci√≥n (recuerda que puedes [**personalizar a tu gusto con html y markdown**]{.hl-yellow}) vamos a crear un [**repositorio de c√≥digo**]{.hl-yellow}.

. . .

Si ya era importante [**trabajar con proyectos**]{.hl-yellow} en `RStudio`, cuando lo combinamos con Github es a√∫n m√°s crucial que creemos un proyecto antes de subir el c√≥digo, as√≠ que vamos a crear uno de prueba que se llame `repo-github-1`.

. . .

En dicho proyecto vamos a [**crear un script**]{.hl-yellow} (en mi caso llamado **codigo.R**) en el que deber√°s hacer los siguientes pasos:

---

## Repo de c√≥digo

1.  [**Carga**]{.hl-yellow} directamente desde la p√°gina del [ISCIII](https://cnecovid.isciii.es/covid19/resources) el archivo llamado `casos_hosp_uci_def_sexo_edad_provres.csv`

```{r}
#| eval: false
#| code-fold: true
# Carga de datos desde ISCIII
datos_covid <- read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
```

. . .

2.  [**Filtra**]{.hl-yellow} datos de Madrid (`"M"`), de 2020 y con sexo conocido (hombre/mujer). Tras ello qu√©date con las columnas `fecha`, `sexo`, `grupo_edad`, `num_casos` (ese orden). Por √∫ltimo obt√©n la suma de casos diarios por fecha y sexo.

```{r}
#| eval: false
#| code-fold: true
# Depuraci√≥n
datos_madrid <-
  datos_covid |>
  # Filtrado por Madrid y fecha
  filter(provincia_iso == "M" & fecha <= "2020-12-31" & sexo != "NC") |> 
  # Selecci√≥n de columnas
  select(provincia_iso:fecha, num_casos) |> 
  # Resumen de casos diarios por fecha y sexo
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
  
```

---

## Repo de c√≥digo

3.  [**Exporta el dataset a un csv**]{.hl-yellow} en una carpeta que se llame `exportado`

```{r}
#| eval: false
#| code-fold: true
# Exportamos datos
write_csv(datos_madrid, file = "./exportado/datos_madrid.csv")
```

. . .

::: columns
::: {.column width="40%"}
4.  Crea una [**gr√°fica de l√≠neas**]{.hl-yellow} que tenga en el eje x fecha, en el eje y casos, con una curva por sexo (gr√°ficas separadas).

```{r}
#| eval: false
#| code-fold: true
# Gr√°fica
ggplot(datos_madrid) +
  geom_line(aes(x = fecha, y = num_casos, color = sexo),
            alpha = 0.6, linewidth = 0.7) +
  scale_color_manual(values = c("#85519D", "#278862")) +
  facet_wrap(~sexo) +
  theme_minimal() +
  theme(legend.position = "bottom")
```
:::

::: {.column width="60%"}
![](./img/ggplot.png){width="380"}
:::
:::

. . .

5.  Tras ello [**exportamos la gr√°fica**]{.hl-yellow}

```{r}
#| eval: false
ggsave(filename = "./exportado/ggplot.png", plot = last_plot(),
       bg = "white", width = 12, height = 8)
```

---

## Repo de c√≥digo

¬øC√≥mo [**subimos el proyecto**]{.hl-yellow}? Vamos de nuevo a [**crear un proyecto de cero**]{.hl-yellow}. Antes no hemos hablado de dos campos importantes:

::: columns
::: {.column width="50%"}
![](./img/repo-1.png){width="460"}
:::

::: {.column width="50%"}
-   `Add .gitignore` nos permitir√° [**seleccionar el lenguaje**]{.hl-yellow} en el que estar√° nuestro proyecto para que Github lo entienda al sincronizar (y no actualice cosas que no deba).

-   `Choose a license` nos permitir√° [**seleccionar la licencia**]{.hl-yellow} que determinar√° las condiciones en las que otros podr√°n reusar tu c√≥digo.
:::
:::

---

## Repo de c√≥digo

::: columns
::: {.column width="50%"}
![](./img/repo-1-1.png)
:::

::: {.column width="50%"}
Si te fijas traer crearlo tenemos solo 3 archivos: el de licencia, el .gitignore y el readme.md (donde deber√≠amos escribir una gu√≠a de uso de lo que hayamos subido)
:::
:::

Para subir los archivos vamos a clickar en [**Add file \< Upload File**]{.hl-purple} y [**arrastraremos TODOS los archivos**]{.hl-yellow} de la carpeta de nuestro proyecto.

---

## Repo de c√≥digo

Tras la subida de archivos tendremos un cuadro llamado [**Commit changes**]{.hl-purple}

![](./img/commit-1.png)

Un [**commit**]{.hl-purple} es una [**modificaci√≥n del repositorio**]{.hl-yellow} con algo que se a√±ade/elimine/modifique, y dicho cuadro es recomendable usarlo para [**resumir en qu√© consiste la modificaci√≥n**]{.hl-yellow}, de manera que quede trazado el cambio.

---

## Repo de c√≥digo

Haciendo click en el reloj donde indica el [**n√∫mero de commits**]{.hl-yellow} accedemos al [**hist√≥rico de commits (cambios)**]{.hl-yellow} con hora, d√≠a, autor, comentarios, etc.

![](./img/commit-reloj.png)

---

## Repo de c√≥digo

Vamos a realizar un [**cambio en nuestro c√≥digo**]{.hl-yellow}: en tu c√≥digo local (local --\> tu ordenador), en lugar de filtrar por Madrid haz el [**filtro por Barcelona**]{.hl-yellow}, guarda el c√≥digo y sube en el repositorio el nuevo archivo (con el mismo nombre, Github har√° la sobrescritura)

```{r}
#| eval: false
#| code-line-numbers: "3"
datos_bcn <-
  datos_covid |>
  filter(provincia_iso == "B" & fecha <= "2020-12-31" & sexo != "NC") |> 
  select(fecha, sexo, grupo_edad, num_casos) |> 
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
```

---

## Consulta de commits

![](./img/barcelona_covid.png){width="550"}

::: columns
::: {.column width="40%"}
Si ahora [**consultamos el commit**]{.hl-yellow}, al lado hay un n√∫mero que lo identifica, y clickando en √©l nos resume los cambios: no solo [**almacena todas las versiones pasadas**]{.hl-yellow} sino que adem√°s nos [**muestra las diferencias entre los archivos cambiados**]{.hl-yellow}
:::

::: {.column width="60%"}
![](./img/commit_cambio.png)
:::
:::

---

## Trazabilidad de cambios

::: columns
::: {.column width="72%"}
![](./img/commit_split.png) ![](./img/commit_unified.png)
:::

::: {.column width="28%"}
Tenemos [**dos modos de visualizaci√≥n**]{.hl-yellow} de los cambios: el modo split nos muestra el antiguo y el nuevo, con las inclusiones en verde y lo que ya no est√° en rojo; y el modo unified nos muestra todo en un mismo documento.
:::
:::

---

## Recuperaci√≥n de commits

![](./img/browse-repo.png)

Github nos permite incluso [**recuperar una versi√≥n del pasado**]{.hl-yellow} de nuestro repositorio, haciendo click en el tercer icono del commit.

---

## Recuperaci√≥n de commits

![](./img/branch-commit.png)

Si te fijas ahora al lado de `1 branch` tenemos un [**men√∫ desplegable**]{.hl-yellow} en el que antes pon√≠a `main` y ahora un n√∫mero identificador del commit. Ya hablaremos de la idea de [**rama (branch)**]{.hl-yellow}

---

## Repo con rmd/qmd

::: columns
::: {.column width="60%"}
Vamos a poner en pr√°ctica lo aprendido:

1.  Crea un nuevo repositorio en Github (llamado `repo-github-2`) donde habr√° alojado con proyecto de R.

2.  Crea un proyecto en `RStudio` que se llame (por ejemplo) `proyecto-qmd`

3.  Una vez dentro del proyecto en `RStudio` haz click en `File < New File < Quarto Document`
:::

::: {.column width="40%"}
![](./img/primer-qmd.png)
:::
:::

Deber√°s tener un documento similar a este: un [**quarto markdown (.qmd)**]{.hl-yellow}, un documento que nos permitir√° incluir [**markdown + c√≥digo**]{.hl-yellow} (puede ser `R` o puede ser `Observable`, `D3`, etc).

---

## Repo con rmd/qmd

Este formato es ideal para:

-   [**Trabajar en equipo**]{.hl-yellow} construyendo el borrador de una pieza.
-   Tomar [**apuntes o informes**]{.hl-yellow} para uno mismo.
-   [**Presentar**]{.hl-yellow} tu trabajo a tus compa√±eros.

::: columns
::: {.column width="50%"}
![](./img/prueba-qmd-html.png)
:::

::: {.column width="50%"}
Si te fijas ahora nuestro repositorio tiene un archivo con formato `.html`...es decir...

[**¬°Es una web!**]{.hl-yellow}
:::
:::

---

## Github pages

¬øC√≥mo [**convertir nuestro repositorio en una web**]{.hl-yellow}?

![](./img/github-pages.png)

1.  Haz click en `Settings`
2.  Ve al apartado `Pages`
3.  En el subapartado `branch` selecciona la √∫nica rama que tenemos ahora (`main`)
4.  Selecciona la carpeta donde tengas el `.html` (en web complejas estar√° como en cualquier web en `docs`, en algo simple estar√° en la ruta raiz del repositorio)
5.  Haz click en `Save`

---

## Github pages

Si te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web est√° en proceso de ser desplegada (deploy)**]{.hl-orange}

![](./img/github-naranja.png)

---

## Github pages

Pasados unos segundos (dependiendo del tama√±o de la web y tu conexi√≥n a internet) ese [**icono pasar√° a ser un check verde**]{.hl-green}: habemus web

![](./img/github-verde.png)

El [**link de la web por defecto**]{.hl-yellow} ser√° `{nombre_usuario}.github.io/{nombre_repo}`

---

## Github pages

![](./img/github-pages-deploy.png)

¬°Un momento! Ahora mismo nuestra web [**no nos est√° mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.

. . .

Para que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este √∫ltimo llam√°ndolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}

---

## Github pages

Vamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro

![](./img/repo-index-html.png)

---

## Github pages

Si [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...

::: columns
::: {.column width="50%"}
![](./img/index-html-qmd.png)
:::

::: {.column width="50%"}
Si a tu `.qmd` ya le llamas de inicio `index.qmd`, autom√°ticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar a√±adiendo un archivo `css` de estilos)

[**Habemus web**]{.hl-green} simplemente clickando en Pages :)
:::
:::

---

## Repo con diapositivas

Vamos a crear el √∫ltimo repositorio que se llamar√° `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.

::: columns
::: {.column width="45%"}
![](img/quarto-slides.png)
:::

::: {.column width="55%"}
La forma de escribir ser√° igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)

Llama al archivo directamente `index.qmd`, s√∫belo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}
:::
:::

---

## Uso de Gitkraken

La forma m√°s [**sencilla para trabajar de manera colaborativa**]{.hl-yellow} en Github, y tenerlo sincronizado con nuestro local, es hacer uso de [Gitkraken](https://www.gitkraken.com/download)

::: columns
::: {.column width="50%"}
![](img/gitkraken-repo.png)
:::

::: {.column width="50%"}
Una vez dentro clickamos en el icono de la carpeta (`Repo Management`) y si ya tenemos el repositorio en Github seleccionamos `Clone`, indicando donde queremos clonar (en nuestro local) y que [**repositorio de Github queremos clonar**]{.hl-yellow}.
:::
:::

---

## Uso de Gitkraken

::: columns
::: {.column width="50%"}
![](img/view-change.png)
:::

::: {.column width="50%"}
Una vez clonado, la idea es que cada [**cambio que hagamos en local nos aparecer√° en Gitkraken**]{.hl-yellow} como `View changes`.
:::
:::

---

## Uso de Gitkraken

Cuando tengas suficientes cambios como para [**actualizar el repositorio**]{.hl-yellow} (tampoco tiene sentido actualizar con cada edici√≥n), ver√°s algo similar a esto con todos los [**commits realizados**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/stage-all-changes.png)
:::

::: {.column width="50%"}
Podr√°s decidir cu√°les de los [**commits locales quieres incluir en remoto**]{.hl-yellow}, bien uno a uno o en `Stage all changes` (para todos)
:::
:::

---

## Uso de Gitkraken

Tras incluir los commits deber√°s incluir un [**t√≠tulo y descripci√≥n del commit**]{.hl-yellow}

![](img/titulo-commit.png)

---

## Uso de Gitkraken

Tras hacerlo ver√°s que ahora tenemos [**dos iconos separados en una especie de √°rbol**]{.hl-yellow} (¬øte acuerdas de la `branch` o rama?):

-   [**Ordenador**]{.hl-purple}: la versi√≥n del repositorio que tienes en tu [**ordenador**]{.hl-yellow}.

-   [**Logo**]{.hl-purple}: la versi√≥n del repositorio que tienes [**subida en remoto**]{.hl-yellow}

![](img/split-gitkraken.png)

---

## Uso de Gitkraken

Mientras eso suceda solo tendr√°s sincronizado tu ordenador con Gitkraken, pero no con Github. Para ello haremos [**click en Push**]{.hl-yellow} (con `Pull` podr√°s forzar a tener en local lo mismo que en remoto).

![](img/push-gitkraken.png)

---

## Branchs

Como hemos mencionado ya en varias ocasiones, hay un elefante en la habitaci√≥n que a√∫n no hemos mentado: las [**ramas o branchs**]{.hl-yellow} de un repositorio.

. . .

Imagina que est√°is trabajando varios en un proyecto y tene√≠s una versi√≥n que funciona pero que quer√©is [**modificar en paralelo a partir del estado actual**]{.hl-yellow} del repositorio.

. . .

Las [**ramas**]{.hl-yellow} nos permiten partir de una versi√≥n com√∫n del repositorio y hacer cambios que [**no afecten a los dem√°s**]{.hl-yellow}

---

## Branchs

Para [**crear una rama**]{.hl-yellow} a partir del estado actual de repositorio haremos click en `Branch` y le pondremos un nombre

![](img/branch-button.png)

Una vez creada ver√°s [**dos iconos**]{.hl-yellow} y un [**men√∫ desplegable**]{.hl-yellow} con las distintas ramas en las que quieres hacer el commit. Imagina que realizas un cambio pero [**no quieres a√±adirlo a la rama principal**]{.hl-yellow}: puedes hacer el [**commit en tu rama propia en LOCAL**]{.hl-yellow} (lo har√°s en la rama activa de tu men√∫ de branchs).

---

## Branchs

La primera vez te pedir√° que escribas la [**rama en REMOTO**]{.hl-yellow} con la quieres sincronizar tu rama en local. [**Consejo**]{.hl-green}: ponle el mismo nombre en remoto que en local.

![](img/name-branch.png)

---

## Branchs

F√≠jate que ahora tenemos el ordenador y el logo en el mismo sitio. Esto no significa que tengas ambas ramas en tu local, solo que [**Gitkraken tiene ambas sincronizadas**]{.hl-yellow}: clickando en cualquiera de ellas, tus archivos en tu ordenador cambiar√°n.

![](img/both-branchs.png)

---

## Pull request

Lo m√°s recomendable es que [**solo se incorpore de una rama secundaria**]{.hl-yellow} a la rama principal aquello que est√° [**validado por un/a coordinador/a**]{.hl-yellow} del repositorio, asegur√°ndose que todo funciona correctamente.

Cuando queramos incluirlo haremos [**click con bot√≥n derecho**]{.hl-yellow} en el icono de la rama secundaria y seleccionamos `Start a pull request to origin from...`

![](img/pull-request-menu.png)

. . .

Una [**pull request**]{.hl-yellow} ser√° una [**petici√≥n al responsable de la rama principal**]{.hl-yellow} para incluir los cambios

---

## Pull request

::: columns
::: {.column width="60%"}
![](img/create-pull-request.png)
:::

::: {.column width="40%"}
En el cuadro que no se abre deberemos escribir:

-   La [**rama**]{.hl-yellow} a la que hacer el `merge` (normalmente la `main`)
-   T√≠tulo y resumen de los cambios
-   Puedes incluso asignar un [**revisor**]{.hl-yellow} entre los colaboradores del repo.
-   Puedes asignar [**etiquetas**]{.hl-yellow}
:::
:::

---

## Pull request

Mientras no se acepte aparecer√° un [**icono de rama**]{.hl-yellow} y un +1 en Pull Requests

![](img/pending-branch.png){width="500"}

. . .

Si somos al mantenedor del repositorio, haciendo click en el men√∫ nos saldr√°n las ramas que nos quieren hacer hacer `merge`

![](img/menu-pr.png){width="500"}

---

## Pull request

Al hacer click se abrir√° un [**cuadro de Pull Request**]{.hl-yellow} para decidir si

-   [**Revisar**]{.hl-yellow} los cambios
-   [**Aprobar**]{.hl-yellow} el `merge`
-   [**A√±adir comentarios**]{.hl-yellow} al que ha solicitado el `merge` por si queremos solicitar alg√∫n cambio [**antes de ser aprobado**]{.hl-yellow}


![](img/menu-pr-2.png)

---

## Pull request

Tras revisar todo y aprobarlo clickaremos en `Confirm merge`, y tras ello podremos decidir si esa rama que era paralela a la principal la queremos [**eliminar**]{.hl-yellow} o dejar visible a todos (consejo: dejar visible para tene [**trazabilidad**]{.hl-yellow} del proyecto de trabajo)

::: columns
::: {.column width="50%"}
![](img/merge-branch.png)
:::

::: {.column width="50%"}
![](img/delete-branch.png)
:::
:::

